name: HPCI-Style Remote Execution

# Test qxub remote execution using container-based approach for SSH compatibility
on:
  workflow_dispatch:
    inputs:
      command:
        description: 'Command to run remotely (will use qxub exec)'
        required: true
        default: 'hostname'
      queue:
        description: 'PBS queue to use'
        required: false
        default: 'copyq'
      walltime:
        description: 'Job walltime'
        required: false
        default: '0:01:00'
  push:
    branches: [ feature/v3.3.0-remote-execution ]

jobs:
  hpci-style-remote:
    permissions:
      contents: "read"
      id-token: "write"
      packages: "read"
    runs-on: self-hosted
    container:
      image: ghcr.io/swarbricklab/qxub-runner:feature-v3.3.0-remote-execution
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: Verify container environment
        run: |
          echo "=== Container Environment Verification ==="
          echo "Operating system:"
          cat /etc/os-release | head -3
          echo ""
          echo "SSH client version:"
          ssh -V
          echo ""
          echo "OpenSSL version:"
          openssl version
          echo ""
          echo "Python version:"
          python --version
          echo ""
          echo "Pre-installed packages:"
          pip list | grep -E "(click|pyyaml|requests)" || echo "Core packages available"
          echo "=== Environment verified ==="
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install qxub in container
        run: |
          echo "Installing qxub in container environment..."
          python -m pip install --upgrade pip
          pip install -e .

          echo "Verifying qxub installation:"
          qxub --version
          echo "qxub installation completed"

      - name: Set up HPCI authentication
        uses: swarbricklab/hpci-scripts/.github/actions/setup-hpci@main
        with:
          submodule_token: ${{ secrets.SUBMODULE_TOKEN }}
          project_id: ${{ secrets.PROJECT_ID }}
          project_number: ${{ secrets.PROJECT_NUMBER }}
          registry_sa: ${{ secrets.REGISTRY_SA }}

      - name: Debug SSH key compatibility
        run: |
          echo "=== SSH Key Compatibility Check ==="
          echo "Container SSH/OpenSSL versions (should be compatible):"
          ssh -V
          openssl version
          echo ""

          echo "Current directory and key file information:"
          pwd
          ls -la atlas_key* || echo "No atlas_key files found"

          # Get absolute path
          KEY_PATH="$(pwd)/atlas_key"
          echo "Key absolute path: $KEY_PATH"

          echo "Detailed key format analysis:"
          echo "Key fingerprint and type:"
          ssh-keygen -l -f "$KEY_PATH" || echo "Key validation failed"

          echo "Key file content (first few lines to check format):"
          head -3 "$KEY_PATH" || echo "Cannot read key file"

          echo "Public key content:"
          cat "${KEY_PATH}.pub" || echo "Cannot read public key file"

          echo "Key type detection:"
          ssh-keygen -l -f "$KEY_PATH" | grep -o 'ED25519\|RSA\|ECDSA\|DSA' || echo "Could not detect key type"

          echo "Testing ssh-agent compatibility (non-blocking):"
          eval $(ssh-agent -s)
          ssh-add "$KEY_PATH" 2>&1 | head -3 || echo "ssh-add test completed (may fail due to format)"
          ssh-add -l 2>/dev/null || echo "No keys in agent (expected if add failed)"

      - name: Configure SSH for Gadi access
        run: |
          mkdir -p ~/.ssh

          # Since xenium workflows work, let's relax host checking for now
          echo "Setting up SSH with relaxed host checking (like xenium workflows)..."

          # Get the absolute path to the SSH key
          KEY_PATH="$(pwd)/atlas_key"
          echo "Using SSH key at: $KEY_PATH"

          # Configure SSH to use atlas_key for Gadi connections with relaxed checking
          cat >> ~/.ssh/config << EOF
          Host gadi.nci.org.au gadi
              HostName gadi.nci.org.au
              User ${{ secrets.USER_NAME }}
              IdentityFile $KEY_PATH
              IdentitiesOnly yes
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
          EOF
          chmod 600 ~/.ssh/config

          echo "SSH config created (with relaxed host checking):"
          cat ~/.ssh/config

      - name: Test SSH connection
        run: |
          echo "=== SSH Connection Test (Relaxed Mode) ==="
          echo "Testing SSH connection with atlas_key using compatible OpenSSL 1.1.1..."

          # Get the absolute path to the SSH key
          KEY_PATH="$(pwd)/atlas_key"
          echo "Testing with key at: $KEY_PATH"

          # Test with relaxed host checking (like xenium workflows)
          echo "Testing SSH with relaxed host checking..."
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              -i "$KEY_PATH" \
              -o BatchMode=yes \
              -o ConnectTimeout=10 \
              ${{ secrets.USER_NAME }}@gadi.nci.org.au \
              "echo 'SSH connection successful from container!' && hostname" || echo "SSH test failed with exit code $?"

          echo "Testing SSH with config file..."
          ssh -F ~/.ssh/config \
              -o BatchMode=yes \
              -o ConnectTimeout=10 \
              gadi.nci.org.au \
              "echo 'SSH config test successful!' && hostname" || echo "SSH config test failed with exit code $?"

          # If the above works, let's also test verbose to see key negotiation
          if [ $? -eq 0 ]; then
            echo "SSH working! Testing with verbose output to see key details..."
            ssh -v -F ~/.ssh/config \
                -o BatchMode=yes \
                -o ConnectTimeout=5 \
                gadi.nci.org.au \
                "echo 'Verbose test successful!'" 2>&1 | grep -E "(key|auth|offer)" | head -10 || true
          fi

      - name: Configure qxub for remote execution
        run: |
          mkdir -p ~/.config/qxub
          cat > ~/.config/qxub/config.yaml << 'EOFCONFIG'
          defaults:
            platform: gadi
            project: a56

          platforms:
            gadi:
              remote:
                host: gadi.nci.org.au
                working_dir: /scratch/a56/${{ secrets.USER_NAME }}/ci-jobs
                conda_init: |
                  eval "$(conda shell.bash hook)"
                  conda activate qxub
          EOFCONFIG
          echo "Generated qxub config:"
          cat ~/.config/qxub/config.yaml

      - name: Execute qxub remote command
        run: |
          QUEUE="${{ github.event.inputs.queue || 'copyq' }}"
          WALLTIME="${{ github.event.inputs.walltime || '0:01:00' }}"
          COMMAND="${{ github.event.inputs.command || 'hostname' }}"

          echo "Executing command on NCI Gadi via qxub:"
          echo "  Queue: $QUEUE"
          echo "  Walltime: $WALLTIME"
          echo "  Command: $COMMAND"

          qxub exec --platform gadi --queue "$QUEUE" --time "$WALLTIME" -vv -- "$COMMAND"

      - name: Clean up
        if: always()
        run: |
          rm -f atlas_key atlas_key.pub
          echo "âœ… Remote execution completed and SSH keys cleaned up"
