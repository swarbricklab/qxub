# v3.3.0 Remote Execution Implementation Plan

## Overview

Implement platform-aware remote execution where platforms can be accessed locally (when on the platform) or remotely (via SSH when off the platform), determined by the presence of a `remote:` section in platform configuration.

## Design Decisions

### 1. Execution Mode Detection
**Decision**: Presence of `remote:` section in platform config determines execution mode
- **Has `remote:` section** → Remote execution via SSH
- **No `remote:` section** → Local execution (direct PBS submission)

### 2. Platform vs Config Separation
**Decision**: Keep platform definitions separate from user configuration
- **Platform definitions**: Immutable facts (queues, limits, billing rates) - same for all users
- **User configuration**: User choices (which platform, SSH details, working dirs) - per-user/per-system

### 3. Platform Definition Loading
**Decision**: Support URL-based platform definition loading with caching
- `file://` - Local file paths
- `https://` - Remote HTTP/HTTPS URLs
- `ssh://` - Fetch via SSH (future)
- No prefix - Search standard locations

### 4. SSH Configuration
**Decision**: Delegate SSH details to `~/.ssh/config`
- Don't duplicate SSH configuration in qxub config
- Platform config only specifies SSH hostname (as defined in `~/.ssh/config`)

### 5. Queue Selection
**Decision**: Local pre-validation + remote final selection
- Local: Validate resources and select queue for better UX (fail fast)
- Remote: Perform final queue selection with current platform state
- Remote definition takes precedence if conflict

## Configuration Schema

### User Configuration Structure

```yaml
# ~/.config/qxub/config.yaml or /etc/xdg/qxub/config.yaml

# Default platform selection
defaults:
  platform: nci_gadi

# Platform registry
platforms:
  # Local platform (no remote section)
  nci_gadi:
    name: nci_gadi
    definition: file:///apps/qxub/platforms/nci_gadi.yaml
    # No remote section → local execution

  # Remote platform (has remote section)
  pawsey_setonix:
    name: pawsey_setonix
    definition: https://github.com/swarbricklab/qxub-platforms/raw/main/pawsey_setonix.yaml
    remote:  # Presence triggers remote execution
      host: setonix  # SSH hostname from ~/.ssh/config
      working_dir: /scratch/{project}/{user}
      conda_init: |  # Optional: custom conda initialization
        eval "$(conda shell.bash hook)"

# Other existing config sections
defaults:
  project: a56
  walltime: "1:00:00"
  mem: 4GB

aliases:
  # ... existing aliases
```

### Platform Definition Structure (Unchanged)

```yaml
# nci_gadi.yaml - Platform definition (no changes needed)
platform:
  name: nci_gadi
  type: pbs_pro
  host: gadi.nci.org.au
  description: "National Computational Infrastructure - Gadi supercomputer"

  queues:
    normal:
      type: standard
      limits:
        max_cores: 48
        max_memory_gb: 192
        max_walltime: "48:00:00"
      su_billing_rate: 1.0

    gpu:
      type: gpu
      limits:
        max_gpus: 4
        max_walltime: "24:00:00"
      su_billing_rate: 3.0

  auto_selection:
    - condition: "gpus > 0"
      queue: gpu
    - condition: "cores <= 48"
      queue: normal
      is_default: true
```

### SSH Configuration (User Managed)

```
# ~/.ssh/config
Host gadi
    HostName gadi.nci.org.au
    User jr9959
    IdentityFile ~/.ssh/id_rsa
    ControlMaster auto
    ControlPersist 10m

Host setonix
    HostName setonix.pawsey.org.au
    User jr9959
    ProxyJump gateway.pawsey.org.au
```

## Implementation Phases

### Phase 1: Configuration Schema (Week 1)

**Goal**: Extend config system to support platform registry

#### Tasks
1. **Update config schema** (`qxub/config/schema.py`)
   - Add `platforms:` section definition
   - Add platform entry schema (name, definition, remote)
   - Add remote config schema (host, working_dir, conda_init)

2. **Update ConfigManager** (`qxub/config/manager.py`)
   - Add `get_platform_config(name)` method
   - Add `list_platforms()` method
   - Add platform registry loading
   - Maintain backward compatibility with existing config

3. **Add validation**
   - Validate platform config structure
   - Check for required fields
   - Warn on deprecated config patterns

**Deliverables**:
- Updated config schema
- Config loading tests
- Migration guide for existing configs

### Phase 2: Platform Definition Loader (Week 1-2)

**Goal**: Load platform definitions from various sources with caching

#### Tasks
1. **Create PlatformLoader class** (`qxub/platform/loader.py`)
   - Support `file://` URLs (local files)
   - Support `https://` URLs (remote fetch)
   - Search standard locations for relative paths
   - Parse platform YAML files
   - Return Platform objects

2. **Implement caching layer** (`qxub/platform/cache.py`)
   - Cache directory: `~/.cache/qxub/platforms/`
   - Store fetched definitions with metadata (source URL, timestamp, ETag)
   - TTL-based invalidation (default: 24 hours)
   - Cache key generation from URL
   - Cache validation and refresh

3. **Add platform resolution**
   - Resolve `definition` URL from platform config
   - Load from cache if valid
   - Fetch from source if cache miss/stale
   - Update cache on successful fetch

**Deliverables**:
- PlatformLoader class with URL support
- Cache implementation with TTL
- Unit tests for loading and caching
- Error handling for fetch failures

### Phase 3: Execution Mode Detection (Week 2)

**Goal**: Determine local vs remote execution based on config

#### Tasks
1. **Add execution mode detection** (`qxub/execution/mode.py`)
   ```python
   def get_execution_mode(platform_config: PlatformConfig) -> ExecutionMode:
       """
       Determine execution mode from platform config.

       Returns:
           ExecutionMode.LOCAL: No remote section in config
           ExecutionMode.REMOTE: Has remote section in config
       """
       if hasattr(platform_config, 'remote') and platform_config.remote:
           return ExecutionMode.REMOTE
       return ExecutionMode.LOCAL
   ```

2. **Add ExecutionMode enum**
   ```python
   from enum import Enum

   class ExecutionMode(Enum):
       LOCAL = "local"
       REMOTE = "remote"
   ```

3. **Integrate with execution flow**
   - Update `execute_unified()` to check execution mode
   - Route to local executor or remote executor accordingly

**Deliverables**:
- ExecutionMode enum
- Detection logic
- Integration with execution flow
- Unit tests for mode detection

### Phase 4: Remote Execution Integration (Week 2-3)

**Goal**: Wire remote executor into main execution flow

#### Tasks
1. **Update RemoteExecutor** (`qxub/remote/executor.py`)
   - Update to use platform config format
   - Use SSH hostname from config (not full URL)
   - Apply working_dir from config
   - Apply custom conda_init if provided
   - Remove hardcoded platform assumptions

2. **Create command serialization** (`qxub/remote/command_builder.py`)
   ```python
   def build_remote_command(
       execution_context: ExecutionContext,
       pbs_options: Dict[str, Any],
       command: List[str]
   ) -> str:
       """
       Build qxub command string for remote execution.

       Serializes execution context, PBS options, and command
       into equivalent qxub CLI invocation.
       """
   ```

   - Serialize execution context (--env, --mod, --sif, etc.)
   - Serialize PBS options (-l, -q, -N, etc.)
   - Serialize command arguments
   - Handle quoting and escaping

3. **Update exec_cli** (`qxub/exec_cli.py`)
   - Add `--platform` option (if not already present)
   - Load platform config from registry
   - Detect execution mode
   - Branch to local or remote executor

4. **Add platform environment variable**
   - Set `QXUB_PLATFORM={platform_name}` for remote execution
   - Remote qxub can detect and use for validation

**Deliverables**:
- Updated RemoteExecutor
- Command serialization logic
- CLI integration with --platform
- End-to-end remote execution working

### Phase 5: Platform Management Commands (Week 3)

**Goal**: CLI tools for managing platforms

#### Tasks
1. **Add platform subcommands** (`qxub/platform_cli.py`)
   ```bash
   qxub platform list                 # List available platforms
   qxub platform show nci_gadi        # Show platform details
   qxub platform validate nci_gadi    # Validate platform definition
   qxub platform refresh nci_gadi     # Refresh cached definition
   qxub platform test nci_gadi        # Test connectivity (if remote)
   qxub platform cache clear          # Clear all cached definitions
   ```

2. **Implement commands**
   - List: Show all platforms with execution mode
   - Show: Display platform definition + config
   - Validate: Check platform YAML structure
   - Refresh: Force re-fetch from source
   - Test: SSH connection test for remote platforms
   - Cache clear: Remove cached definitions

**Deliverables**:
- Platform management commands
- Help text and documentation
- Tests for commands

### Phase 6: Documentation (Week 3-4)

**Goal**: Comprehensive user and developer documentation

#### Tasks
1. **Update user documentation**
   - `docs/remote-execution.md` - Remote execution guide
   - `docs/configuration.md` - Platform configuration
   - `docs/examples.md` - Add remote execution examples

2. **Create migration guide**
   - How to convert existing configs
   - System admin setup guide
   - GitHub Actions setup examples

3. **Update developer docs**
   - Architecture overview
   - Platform definition guide
   - Cache implementation details

**Deliverables**:
- Updated documentation
- Migration guide
- Example configurations

### Phase 7: Testing (Week 4)

**Goal**: Comprehensive test coverage

#### Tasks
1. **Unit tests**
   - Config loading and validation
   - Platform loading and caching
   - Execution mode detection
   - Command serialization
   - Remote executor (mocked SSH)

2. **Integration tests**
   - End-to-end local execution
   - End-to-end remote execution (requires SSH setup)
   - Cache invalidation and refresh
   - Error handling and recovery

3. **Manual testing scenarios**
   - Test from Gadi (local execution)
   - Test from laptop (remote execution)
   - Test GitHub Actions workflow
   - Cross-platform submission (Gadi → Pawsey)

**Deliverables**:
- Comprehensive test suite
- Test documentation
- CI integration

## Technical Details

### Execution Flow: Local

```
User: qxub exec --platform nci_gadi --env pytorch -- python train.py
  ↓
Load config → platforms.nci_gadi
  ↓
Check remote section → None found
  ↓
Execution mode: LOCAL
  ↓
Load platform definition → file:///apps/qxub/platforms/nci_gadi.yaml
  ↓
Parse execution context → Conda: pytorch
  ↓
Parse PBS options → defaults from config
  ↓
Queue selection → auto-select or use specified
  ↓
Generate job script
  ↓
Submit to PBS → qsub
  ↓
Monitor job
```

### Execution Flow: Remote

```
User: qxub exec --platform nci_gadi --env pytorch -- python train.py
  ↓
Load config → platforms.nci_gadi
  ↓
Check remote section → Found: {host: gadi, working_dir: /scratch/...}
  ↓
Execution mode: REMOTE
  ↓
Load platform definition → https://github.com/.../nci_gadi.yaml (with cache)
  ↓
Pre-validate resources locally
  ↓
Build remote command:
  "cd /scratch/a56/jr9959 && qxub exec --env pytorch -- python train.py"
  ↓
Set environment: QXUB_PLATFORM=nci_gadi
  ↓
Build SSH command:
  ssh -F ~/.ssh/config gadi "cd /scratch/... && qxub exec ..."
  ↓
Execute SSH command
  ↓
Stream output to local terminal
  ↓
Return exit code
```

### Command Serialization

**Input** (parsed from CLI):
```python
ExecutionContext(
    type=ContextType.CONDA,
    env="pytorch"
)
pbs_options = {
    'queue': 'auto',
    'walltime': '2:00:00',
    'mem': '8GB',
    'cpus': 4
}
command = ['python', 'train.py', '--epochs', '100']
```

**Output** (serialized for remote):
```bash
qxub exec \
  --env pytorch \
  --queue auto \
  --walltime 2:00:00 \
  --mem 8GB \
  --cpus 4 \
  -- python train.py --epochs 100
```

### Cache Structure

```
~/.cache/qxub/platforms/
├── nci_gadi.yaml                          # Cached platform definition
├── nci_gadi.yaml.meta                     # Cache metadata
│   {
│     "source": "https://github.com/.../nci_gadi.yaml",
│     "fetched": "2025-10-27T10:30:00Z",
│     "etag": "abc123...",
│     "ttl": 86400
│   }
├── pawsey_setonix.yaml
└── pawsey_setonix.yaml.meta
```

### Error Handling

**Scenario 1: Platform not found**
```
Error: Platform 'nci_gadi' not found in configuration
Available platforms: local_cluster, pawsey_setonix
```

**Scenario 2: Remote access not configured**
```
Error: Platform 'nci_gadi' has no remote access configured
Cannot execute remotely without 'remote:' section in platform config
```

**Scenario 3: SSH connection failure**
```
Error: Cannot connect to platform 'nci_gadi' via SSH
Host: gadi (from ~/.ssh/config)
Troubleshooting:
  - Check SSH configuration in ~/.ssh/config
  - Verify network connectivity
  - Test connection: ssh gadi echo 'test'
```

**Scenario 4: Platform definition fetch failure**
```
Error: Cannot load platform definition for 'nci_gadi'
Source: https://github.com/.../nci_gadi.yaml
Reason: HTTP 404 Not Found

Using cached version from: ~/.cache/qxub/platforms/nci_gadi.yaml
Warning: Cache is 7 days old
```

## Backward Compatibility

### Existing Behavior Preserved

1. **No `--platform` specified**: Use `defaults.platform` from config
2. **Built-in platforms**: Continue to work as before
3. **Existing config format**: Remains valid (no `platforms:` section needed initially)

### Migration Path

**Old config** (still works):
```yaml
defaults:
  project: a56
  queue: normal
```

**New config** (recommended):
```yaml
defaults:
  platform: nci_gadi
  project: a56

platforms:
  nci_gadi:
    name: nci_gadi
    definition: file:///apps/qxub/platforms/nci_gadi.yaml
```

## Success Criteria

### Functional Requirements
- [ ] Platform registry loads from config
- [ ] Platform definitions load from file:// and https:// URLs
- [ ] Platform definitions cached with TTL-based invalidation
- [ ] Execution mode detected from presence of `remote:` section
- [ ] Local execution works unchanged
- [ ] Remote execution via SSH works end-to-end
- [ ] Command serialization preserves all options
- [ ] Queue selection works locally and remotely
- [ ] Platform management commands functional

### Non-Functional Requirements
- [ ] Backward compatible with existing configs
- [ ] Clear error messages for misconfigurations
- [ ] Fast platform definition loading (cache hit < 10ms)
- [ ] SSH connection reuse via ControlMaster
- [ ] Comprehensive test coverage (>80%)
- [ ] Documentation complete and accurate

### User Experience
- [ ] Platform-independent scripts work correctly
- [ ] Same config file works on different systems (with appropriate platform sections)
- [ ] Cross-platform submission works (Gadi → Pawsey)
- [ ] GitHub Actions integration functional
- [ ] Error messages guide users to solutions

## Risks and Mitigations

### Risk 1: SSH Configuration Complexity
**Mitigation**: Provide clear documentation and examples for `~/.ssh/config` setup

### Risk 2: Platform Definition Sync Issues
**Mitigation**: Cache with TTL, allow force refresh, version in URLs if needed

### Risk 3: Command Serialization Edge Cases
**Mitigation**: Comprehensive testing, proper quoting/escaping, support `--cmd` alternative

### Risk 4: Network Failures During Fetch
**Mitigation**: Use cached version with warning, implement retry logic

### Risk 5: Breaking Changes to Config Schema
**Mitigation**: Maintain backward compatibility, provide migration tools

## Future Enhancements (Post v3.3.0)

### v3.4.0: Platform Definition Fetching Enhancements
- SSH URL support for platform definitions
- ETag-based cache validation for HTTP
- Platform definition versioning
- Auto-discovery from central repositories

### v3.5.0: Portable Projects
- Git repository cloning on remote
- DVC integration
- Smart working directory management
- See Issue #24

### v3.6.0: Environment Forwarding
- Conda environment export/import
- Docker → Singularity conversion
- Module abstraction layer
- See Issue #25

### v4.0.0: Multi-Cloud Support
- AWS Batch backend
- Azure Batch backend
- Kubernetes backend
- Unified platform abstraction

## Timeline

| Phase | Duration | Start | End | Deliverables |
|-------|----------|-------|-----|--------------|
| Phase 1: Config Schema | 3 days | Week 1 | Week 1 | Config system updates |
| Phase 2: Platform Loader | 5 days | Week 1 | Week 2 | Loader + cache |
| Phase 3: Mode Detection | 2 days | Week 2 | Week 2 | Execution routing |
| Phase 4: Remote Integration | 5 days | Week 2 | Week 3 | End-to-end remote |
| Phase 5: Platform Commands | 3 days | Week 3 | Week 3 | Management CLI |
| Phase 6: Documentation | 4 days | Week 3 | Week 4 | Docs + migration |
| Phase 7: Testing | 5 days | Week 4 | Week 4 | Test suite |

**Total: ~4 weeks**

## Review Checkpoints

- **End of Week 1**: Config schema and platform loading working
- **End of Week 2**: Remote execution functional end-to-end
- **End of Week 3**: Platform commands and basic docs complete
- **End of Week 4**: Testing complete, ready for release

## Related Documentation

- [Remote Execution Analysis](./remote-execution-analysis.md)
- [Platform Config Separation](./platform-config-separation.md)
- [Issue #24: Portable Projects](https://github.com/swarbricklab/qxub/issues/24)
- [Issue #25: Environment Context Forwarding](https://github.com/swarbricklab/qxub/issues/25)
