#! /bin/bash
#PBS -N qdefault
#PBS -P a56
#PBS -l storage=gdata/a56
#PBS -S /bin/bash
#PBS -W umask=0027
#PBS -j oe

# Logging
echo "ðŸ“ Execution directory: $cwd"
echo "ðŸ”§ Default execution (no environment activation)"

# Decode base64 encoded commands
if [ -n "$cmd_b64" ]; then
    cmd=$(echo "$cmd_b64" | base64 -d)
fi
if [ -n "$pre_cmd_b64" ]; then
    pre_cmd=$(echo "$pre_cmd_b64" | base64 -d)
fi
if [ -n "$post_cmd_b64" ]; then
    post_cmd=$(echo "$post_cmd_b64" | base64 -d)
fi

echo "ðŸ’» Command: $cmd"
if [ -n "$pre_cmd" ]; then
    echo "âš¡ Pre-command: $pre_cmd"
fi
if [ -n "$post_cmd" ]; then
    echo "ðŸ Post-command: $post_cmd"
fi
echo "ðŸ“„ STDOUT file: $out"
echo "ðŸ“„ STDERR file: $err"
echo "ðŸ”‡ Quiet mode: $quiet"
if [ "$quiet" = "true" ]; then
    echo "â„¹ï¸  Note: In quiet mode, output will go to PBS joblog instead of separate files"
fi
echo "ðŸ‘¤ Current user: $(whoami)"
echo "ðŸ“ Current directory: $(pwd)"

# Strict mode with error handling
set -e

# Create status directory for file-based monitoring
STATUS_DIR="${out%/*}/status"
mkdir -p "$STATUS_DIR"

# Signal job started with timestamp and job ID
echo "$(date -Iseconds)" > "$STATUS_DIR/job_started_${PBS_JOBID:-unknown}"
echo "${PBS_JOBID:-unknown}" >> "$STATUS_DIR/job_started_${PBS_JOBID:-unknown}"
echo "ðŸš€ Job started at $(date -Iseconds)"

# Error handler function
error_handler() {
    local exit_code=$?
    echo "âŒ ERROR: Command failed with exit code $exit_code"
    echo "âŒ Failed command: $BASH_COMMAND"
    # Write error exit code to status
    echo "$exit_code" > "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
    echo "$(date -Iseconds)" >> "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
    exit $exit_code
}

# Set trap for error handling
trap error_handler ERR

# Check required variables
if [ -z "$cmd" ]; then
    echo "âŒ ERROR: No command provided"
    exit 1
fi

if [ -z "$cwd" ]; then
    echo "âŒ ERROR: No working directory provided"
    exit 1
fi

# Change to execution directory
cd "$cwd" || { echo "âŒ ERROR: Failed to change to directory $cwd"; exit 1; }

# Set output redirection for quiet mode
if [ "$quiet" = "true" ]; then
    # In quiet mode, don't redirect stdout/stderr to files
    exec_prefix=""
else
    # Create output directories
    out_dir=$(dirname "$out")
    err_dir=$(dirname "$err")

    mkdir -p "$out_dir" "$err_dir"

    # Test write permissions
    if ! touch "$out" "$err"; then
        echo "âŒ ERROR: Cannot write to output files $out and $err"
        exit 1
    fi

    exec_prefix="exec 1>\"$out\" 2>\"$err\""
fi

# Execute pre-command if provided
if [ -n "$pre_cmd" ]; then
    echo "âš¡ Executing pre-command..."
    echo "$(date -Iseconds)" > "$STATUS_DIR/pre_started"

    if [ "$quiet" = "true" ]; then
        eval "$pre_cmd"
        PRE_EXIT_CODE=$?
    else
        eval "$exec_prefix; $pre_cmd"
        PRE_EXIT_CODE=$?
    fi

    echo "$PRE_EXIT_CODE" > "$STATUS_DIR/pre_exit_code"
    echo "$(date -Iseconds)" >> "$STATUS_DIR/pre_exit_code"

    if [ $PRE_EXIT_CODE -ne 0 ]; then
        echo "âŒ Pre-command failed with exit code $PRE_EXIT_CODE"
        echo "$PRE_EXIT_CODE" > "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
        echo "$(date -Iseconds)" >> "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
        exit $PRE_EXIT_CODE
    fi
    echo "âœ… Pre-command completed"
fi

# Execute main command
echo "ðŸ’» Executing main command..."
echo "$(date -Iseconds)" > "$STATUS_DIR/main_started_${PBS_JOBID:-unknown}"

if [ "$quiet" = "true" ]; then
    eval "$cmd"
    MAIN_EXIT_CODE=$?
else
    eval "$exec_prefix; $cmd"
    MAIN_EXIT_CODE=$?
fi

echo "$MAIN_EXIT_CODE" > "$STATUS_DIR/main_exit_code"
echo "$(date -Iseconds)" >> "$STATUS_DIR/main_exit_code"

if [ $MAIN_EXIT_CODE -ne 0 ]; then
    echo "âŒ Main command failed with exit code $MAIN_EXIT_CODE"
    echo "$MAIN_EXIT_CODE" > "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
    echo "$(date -Iseconds)" >> "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
    exit $MAIN_EXIT_CODE
fi
echo "âœ… Command completed successfully"

# Execute post-command if provided
if [ -n "$post_cmd" ]; then
    echo "ðŸ Executing post-command..."
    echo "$(date -Iseconds)" > "$STATUS_DIR/post_started"

    if [ "$quiet" = "true" ]; then
        eval "$post_cmd"
        POST_EXIT_CODE=$?
    else
        eval "$exec_prefix; $post_cmd"
        POST_EXIT_CODE=$?
    fi

    echo "$POST_EXIT_CODE" > "$STATUS_DIR/post_exit_code"
    echo "$(date -Iseconds)" >> "$STATUS_DIR/post_exit_code"

    if [ $POST_EXIT_CODE -ne 0 ]; then
        echo "âŒ Post-command failed with exit code $POST_EXIT_CODE"
        echo "$POST_EXIT_CODE" > "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
        echo "$(date -Iseconds)" >> "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
        exit $POST_EXIT_CODE
    fi
    echo "âœ… Post-command completed"
fi

# Determine final exit code (should be 0 if we reach here)
FINAL_EXIT_CODE=${MAIN_EXIT_CODE:-0}

# Write final exit code and completion marker
echo "$FINAL_EXIT_CODE" > "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"
echo "$(date -Iseconds)" >> "$STATUS_DIR/final_exit_code_${PBS_JOBID:-unknown}"

echo "ðŸŽ‰ Job completed successfully"
